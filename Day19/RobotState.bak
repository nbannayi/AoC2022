namespace AoC2022.Day19

open System.Collections.Generic

type RobotState =
    {
        Blueprint:          Blueprint
        OreCount:           int
        ClayCount:          int
        ObsidianCount:      int
        GeodeCount:         int
        OreRobotCount:      int
        ClayRobotCount:     int
        ObsidianRobotCount: int
        GeodeRobotCount:    int
    }

type BuildOption =
    | Ore
    | Clay
    | Obsidian
    | Geode
    | Wait

module RobotState =

    let create blueprint =
        {
            Blueprint          = blueprint
            OreCount           = 0          
            ClayCount          = 0         
            ObsidianCount      = 0     
            GeodeCount         = 0        
            OreRobotCount      = 1     
            ClayRobotCount     = 0    
            ObsidianRobotCount = 0
            GeodeRobotCount    = 0   
        }

    let private buildOreRobot robotState =
        let blueprint = robotState.Blueprint
        let oreRobotCount, oreCount =
            if robotState.OreCount >= blueprint.OreRobotCost then
                robotState.OreRobotCount+1, robotState.OreCount - blueprint.OreRobotCost
            else
                robotState.OreRobotCount, robotState.OreCount
        {robotState with OreCount = oreCount; OreRobotCount = oreRobotCount}

    let private buildClayRobot robotState =
        let blueprint = robotState.Blueprint
        let clayRobotCount, oreCount =
            if robotState.OreCount >= blueprint.ClayRobotCost then
                robotState.ClayRobotCount+1, robotState.OreCount - blueprint.ClayRobotCost
            else
                robotState.ClayRobotCount, robotState.OreCount
        {robotState with OreCount = oreCount; ClayRobotCount = clayRobotCount}

    let private buildObsidianRobot robotState =
        let blueprint = robotState.Blueprint
        let obsidianRobotCount, oreCount, clayCount =
            if robotState.OreCount >= blueprint.ObsidianRobotCost.OreCost && robotState.ClayCount >= blueprint.ObsidianRobotCost.ClayCost then
                robotState.ObsidianRobotCount+1, robotState.OreCount - blueprint.ObsidianRobotCost.OreCost, robotState.ClayCount - robotState.Blueprint.ObsidianRobotCost.ClayCost
            else
                robotState.ObsidianRobotCount, robotState.OreCount, robotState.ClayCount
        {robotState with OreCount = oreCount; ClayCount = clayCount; ObsidianRobotCount = obsidianRobotCount}

    let private buildGeodeRobot robotState =
        let blueprint = robotState.Blueprint
        let geodeRobotCount, oreCount, obsidianCount =
            if robotState.OreCount >= blueprint.GeodeRobotCost.OreCost && robotState.ObsidianCount >= blueprint.GeodeRobotCost.ObsidianCost then
                robotState.GeodeRobotCount+1, robotState.OreCount - blueprint.GeodeRobotCost.OreCost, robotState.ObsidianCount - robotState.Blueprint.GeodeRobotCost.ObsidianCost
            else
                robotState.GeodeRobotCount, robotState.OreCount, robotState.ObsidianCount
        {robotState with OreCount = oreCount; ObsidianCount = obsidianCount; GeodeRobotCount = geodeRobotCount}

    let collect robotState =        
        {
            robotState with
                OreCount      = robotState.OreCount      + robotState.OreRobotCount
                ClayCount     = robotState.ClayCount     + robotState.ClayRobotCount
                ObsidianCount = robotState.ObsidianCount + robotState.ObsidianRobotCount
                GeodeCount    = robotState.GeodeCount    + robotState.GeodeRobotCount
        }

    let buildRobot buildOption robotState =
        let robotState' = robotState |> collect
        match buildOption with
        | Ore      -> buildOreRobot      robotState'
        | Clay     -> buildClayRobot     robotState'
        | Obsidian -> buildObsidianRobot robotState'
        | Geode    -> buildGeodeRobot    robotState'
        | Wait     -> robotState'

    let getBuildOptions robotState =
        let blueprint = robotState.Blueprint
        let maxSpendRate =
            [blueprint.OreRobotCost; blueprint.ClayRobotCost; blueprint.ObsidianRobotCost.OreCost; blueprint.GeodeRobotCost.OreCost]
            |> List.max
        // Only build an Ore robot if the number of Ore robots is below the spend rate.
        let buildOreRobot      = robotState.OreCount >= blueprint.OreRobotCost && robotState.OreRobotCount < maxSpendRate
        let buildClayRobot     = robotState.OreCount >= blueprint.ClayRobotCost && robotState.ClayRobotCount < blueprint.ObsidianRobotCost.ClayCost
        let buildObsidianRobot =
            robotState.OreCount >= blueprint.ObsidianRobotCost.OreCost && robotState.ClayCount >= blueprint.ObsidianRobotCost.ClayCost &&
            robotState.ObsidianRobotCount < blueprint.GeodeRobotCost.ObsidianCost
        let buildGeodeRobot =
            robotState.OreCount >= blueprint.GeodeRobotCost.OreCost && robotState.ObsidianCount >= blueprint.GeodeRobotCost.ObsidianCost

        [buildOreRobot; buildClayRobot; buildObsidianRobot; buildGeodeRobot; true]
        |> List.zip [Ore; Clay; Obsidian; Geode; Wait]
        |> List.filter (fun (_,b) -> b = true)
        |> List.map (fst)        
    
    let display robotState =
        printfn "Ore Rocks/Robots: %d/%d, Clay Rocks/Robots: %d/%d, Obsidian Rocks/Robots: %d/%d, Geode Rocks/Robots: %d/%d"
            robotState.OreCount      robotState.OreRobotCount      robotState.ClayCount  robotState.ClayRobotCount
            robotState.ObsidianCount robotState.ObsidianRobotCount robotState.GeodeCount robotState.GeodeRobotCount
        
    let getMaxGeodes maxMinutes robotState =        
        let queue = new Queue<RobotState*int>([robotState,0])
        let cache = new Dictionary<RobotState*BuildOption*int,int>()
        seq {
            while queue.Count > 0 do
                let robotState', minutes = queue.Dequeue()                                
                match minutes = maxMinutes with
                | true ->
                    queue.Clear()                    
                | false ->                                                         
                    for bo in robotState' |> getBuildOptions do                                            
                        if cache.ContainsKey(robotState',bo,minutes+1) then
                            yield cache.[robotState',bo,minutes+1]
                        else
                            let rs = robotState' |> buildRobot bo
                            yield rs.GeodeCount                            
                            cache.Add((robotState',bo,minutes+1),rs.GeodeCount)
                            queue.Enqueue(rs,minutes+1)
         } |> Seq.max

        